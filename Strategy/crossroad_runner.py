import asyncio
import json
import os
import sys
import threading
from typing import Optional

try:
    import websockets  # type: ignore
except ImportError as exc:  # pragma: no cover - runtime env check
    raise SystemExit("依赖缺失: 请先运行 pip install websockets") from exc

import traci

import algorithms  # 导入算法模块
# --- SUMO环境配置 ---
if 'SUMO_HOME' in os.environ:
    tools = os.path.join(os.environ['SUMO_HOME'], 'tools')
    sys.path.append(tools)
else:
    sys.exit("请设置环境变量 'SUMO_HOME'")


class SumoWebsocketStreamer:
    """Minimal WebSocket broadcaster that pushes SUMO vehicle state to clients."""

    def __init__(self, host: str = "0.0.0.0", port: int = 8765):
        self.host = host
        self.port = port
        self.clients = set()
        self.server = None
        self.loop = None
        self.thread = None

    async def _handler(self, websocket):
        self.clients.add(websocket)
        try:
            await websocket.wait_closed()
        finally:
            self.clients.discard(websocket)

    async def _broadcast(self, message: str):
        stale = set()
        for ws in set(self.clients):
            try:
                await ws.send(message)
            except Exception:
                stale.add(ws)
        for ws in stale:
            self.clients.discard(ws)

    def broadcast(self, message: str):
        if not self.loop:
            return
        asyncio.run_coroutine_threadsafe(self._broadcast(message), self.loop)

    async def _serve(self):
        self.server = await websockets.serve(self._handler, self.host, self.port)
        print(f"[WS] SUMO stream listening on ws://{self.host}:{self.port}")

    def start(self):
        if self.thread:
            return

        def _run_loop():
            self.loop = asyncio.new_event_loop()
            asyncio.set_event_loop(self.loop)
            try:
                self.loop.run_until_complete(self._serve())
                self.loop.run_forever()
            except Exception as e:  # pragma: no cover - runtime logging
                print(f"[WS] stream loop error: {e}")
            finally:
                pending = asyncio.all_tasks(loop=self.loop)
                for task in pending:
                    task.cancel()
                self.loop.run_until_complete(self.loop.shutdown_asyncgens())
                self.loop.close()

        self.thread = threading.Thread(target=_run_loop, daemon=True)
        self.thread.start()

    def stop(self):
        if self.server and self.loop:
            self.loop.call_soon_threadsafe(self.server.close)
            self.loop.call_soon_threadsafe(self.loop.stop)
        if self.thread:
            self.thread.join(timeout=1)
            self.thread = None

class VehicleGenerator:
    """
    Dummy generator class - vehicles are now generated by SUMO flows in crossroad.rou.xml
    This class is kept for compatibility but does nothing.
    """
    def __init__(self, step_interval=None):
        # No longer needed - SUMO handles vehicle generation
        pass
        
    def update(self, step):
        """No-op - SUMO flows handle vehicle generation automatically"""
        pass

class SimulationManager:
    """
    仿真管理器，用于设置和运行SUMO仿真。
    """
    def __init__(self, sumo_cmd, max_steps,
                 driving_strategy=None,
                 scheduling_algo=None,
                 consensus_algo=None,
                 networking_proto=None,
                 vehicle_generator=None,
                 stream_port: Optional[int] = 8765):
        self.sumo_cmd = sumo_cmd
        self.max_steps = max_steps
        self.driving_strategy = driving_strategy
        self.scheduling_algo = scheduling_algo
        self.consensus_algo = consensus_algo
        self.networking_proto = networking_proto
        self.vehicle_generator = vehicle_generator
        self.streamer = SumoWebsocketStreamer(port=stream_port) if stream_port else None

    def run(self):
        """执行TraCI控制循环"""
        if self.streamer:
            self.streamer.start()

        traci.start(self.sumo_cmd)
        step = 0

        try:
            while step < self.max_steps:
                traci.simulationStep()

                if self.driving_strategy:
                    self.driving_strategy.update(step)
                if self.scheduling_algo:
                    self.scheduling_algo.update(step)
                if self.networking_proto:
                    self.networking_proto.update(step)
                if self.consensus_algo:
                    self.consensus_algo.update(step)
                if self.vehicle_generator:
                    self.vehicle_generator.update(step)

                if self.streamer:
                    vehicles = []
                    for vid in traci.vehicle.getIDList():
                        x, y = traci.vehicle.getPosition(vid)
                        speed = traci.vehicle.getSpeed(vid)
                        angle = traci.vehicle.getAngle(vid)  # SUMO angle: 0=North, clockwise
                        vehicles.append({"id": vid, "x": float(x), "y": float(y), "speed": float(speed), "angle": float(angle)})

                    tls = []
                    try:
                        for tl_id in traci.trafficlight.getIDList():
                            state = traci.trafficlight.getRedYellowGreenState(tl_id)
                            links = traci.trafficlight.getControlledLinks(tl_id)
                            green_h = 0
                            green_v = 0
                            signals = []
                            lane_counts = {}

                            for idx, link_group in enumerate(links):
                                if not link_group:
                                    continue
                                incoming_lane = link_group[0][0]
                                try:
                                    lane_idx = int(incoming_lane.split('_')[-1])
                                except Exception:
                                    lane_idx = 0

                                incoming_edge = incoming_lane.split('_')[0]
                                orient = incoming_edge[0].upper() if incoming_edge else ''

                                if orient in ('E', 'W') and state[idx] in ('G', 'g'):
                                    green_h += 1
                                if orient in ('N', 'S') and state[idx] in ('G', 'g'):
                                    green_v += 1

                                lane_counts[orient] = max(lane_counts.get(orient, -1), lane_idx)
                                signals.append({
                                    "index": idx,
                                    "orientation": orient,
                                    "lane": lane_idx,
                                    "state": state[idx],
                                    "incoming": incoming_lane,
                                    "outgoing": link_group[0][1]
                                })

                            lane_counts = {k: v + 1 for k, v in lane_counts.items()}  # convert max lane idx to count
                            phase = 'horizontal' if green_h >= green_v else 'vertical'
                            tls.append({
                                "id": tl_id,
                                "state": state,
                                "phase": phase,
                                "currentPhase": traci.trafficlight.getPhase(tl_id),
                                "program": traci.trafficlight.getProgram(tl_id),
                                "signals": signals,
                                "laneCounts": lane_counts
                            })
                    except Exception:
                        pass

                    # Collect consensus events from algorithms
                    events = []
                    if self.consensus_algo and hasattr(self.consensus_algo, 'get_events'):
                        events.extend(self.consensus_algo.get_events())
                    if self.networking_proto and hasattr(self.networking_proto, 'get_events'):
                        events.extend(self.networking_proto.get_events())
                    
                    payload = json.dumps({
                        "step": step, 
                        "vehicles": vehicles, 
                        "tls": tls,
                        "events": events
                    })
                    self.streamer.broadcast(payload)

                step += 1
        except traci.exceptions.TraCIException as e:
            print(f"TraCI error during simulation: {e}")
        finally:
            traci.close()
            if self.streamer:
                self.streamer.stop()

if __name__ == "__main__":
    # --- 仿真参数 ---
    sumoBinary = "sumo-gui"  # 使用 "sumo-gui" 或 "sumo"
    sumoCmd = [sumoBinary, "-c", "crossroad.sumocfg"]
    SIMULATION_STEPS = 5000
    STREAM_PORT = 8765  # WebSocket 推送端口，前端默认连接到此端口

    # --- 实例化算法 ---
    # 根据crossroad.net.xml，交通灯ID是"J0"
    my_driving_strategy = algorithms.MyDrivingStrategy()
    my_traffic_light_scheduling = algorithms.MyTrafficLightScheduling(junction_id="J0")
    my_consensus = algorithms.MyConsensus()
    my_networking = algorithms.MyNetworking()
    
    # Instantiate continuous vehicle generator
    GENERATION_INTERVAL = 60  # Set vehicle generation interval (steps)
    my_vehicle_generator = VehicleGenerator(step_interval=GENERATION_INTERVAL)

    # --- 运行仿真 ---
    print("正在启动十字路口仿真...")
    manager = SimulationManager(
        sumoCmd,
        SIMULATION_STEPS,
        driving_strategy=my_driving_strategy,
        scheduling_algo=my_traffic_light_scheduling,
        consensus_algo=my_consensus,
        networking_proto=my_networking,
        vehicle_generator=my_vehicle_generator,
        stream_port=STREAM_PORT
    )
    manager.run()
    print("十字路口仿真结束。")
